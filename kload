#!/bin/bash
#
# kload - a syslinux.cfg parser for autoloading a kernel for kexec
#

bootloadercfg=/boot/syslinux/syslinux.cfg

error() {
  local mesg=$1; shift
  printf "==> ERROR: $mesg\n" "$@"
} >&2

die() {
  error "$@"
  exit 1
}

usage() {
  cat <<EOF
usage: ${0##*/} <label> [rootoptions]

${0##*/} parses syslinux's bootloader configuration and automates the process
of loading a new kernel for kexec.

  Options:
    -f <file>   use another config file (default: /boot/syslinux/syslinux.cfg)
    -h          display this help message.
    -l          display available kernels by label

EOF
  exit 1
}

parse_syslinux_config() {
  local found=0

  while read -r key value; do
    [[ -z $key || ${key:0:1} = '#' ]] && continue

    if [[ $key = LABEL ]]; then
      if [[ $value != "$1" ]]; then
        (( found )) && return || continue
      fi
      found=1
    fi

    (( found )) || continue

    case $key in
      LINUX|KERNEL)
        kernel="$value"
        ;;
      APPEND|INITRD)
        declare -g "${key,,}=$value"
        ;;
    esac
  done <"$bootloadercfg"
}

show_labels() {
  awk '
    function longest(list,       listlen,i, len, maxlen) {
      maxlen = 0
      listlen = length(list)
      for(i in list) {
        len = length(i)
        if (len > maxlen) {
          maxlen = len
        }
      }
      return maxlen
    }

    function add_label(config, label, kernel, append, initrd) {
      if (label && kernel && append) {
        config[label] = kernel SUBSEP append SUBSEP initrd
      }
    }

    function print_human(config) {
      len = longest(config)

      printf "%-*s\t%s\n", len, "label", "kernel image [initrd]"
      printf "%*-s\t%s\n", len, "", "options"
      print "-------------------------------------------------------------"
      for (label in config) {
        if (config[label]) {
          # opts[label] = <kernel> <append> [initrd]
          split(config[label], opts, SUBSEP)
          printf "%-*s\t%s", len, label, opts[1]
          if(opts[3]) {
            printf " [%s]", opts[3]
          }
          printf "\n%*s\t%s\n", len, "", opts[2]
        }
      }
    }

    $1 == "LABEL" {
      label = $2
      kernel = ""; append = ""; initrd = ""
    }

    $1 ~ /^(LINUX|KERNEL)$/ {
      sub(/^[[:blank:]]*(LINUX|KERNEL) /, "")
      kernel = $0
    }

    $1 == "APPEND" {
      sub(/^[[:blank:]]*APPEND /, "")
      gsub(/\t/, " ")

      if (append) {
        append = append " " $0
      } else {
        append = $0
      }
    }

    $1 == "INITRD" {
      sub(/^[[:blank:]]*[^[:blank:]]+ /, "")
      initrd = $0
    }

    /^[[:blank:]]*$/ {
      add_label(config, label, kernel, append, initrd)
    }

    END {
      print_human(config)
    }
  ' "$bootloadercfg"
  exit 0
}

runcmd() {
  if (( needsroot )); then
    if sudo -v &>/dev/null && sudo -l &>/dev/null; then
      sudo "$@"
    else
      printf '%s ' 'root'
      su -c "$(printf '%q ' "$@")"
    fi
  fi
}

# main()
while getopts ":f:hl" flag; do
  case $flag in
    f) bootloadercfg=$OPTARG ;;
    h) usage ;;
    l) show_labels ;;
    :) die "option '--%s' requires an argument" "$OPTARG" ;;
    ?) die "invalid option -- '%s'" "$OPTARG" ;;
  esac
done
shift $(( OPTIND - 1 ))

[[ -f $bootloadercfg ]] || die "unable to find bootloader config: %s" "$bootloadercfg"

label=$1; shift
[[ $label ]] || die "no label specified (use -h for help)"

(( UID == 0 )) || needsroot=1

parse_syslinux_config "$label"
[[ -z $kernel || -z $append ]] && die "failed to find label \`%s'" "$label"

kexec_cmd=(kexec -l "/boot/${kernel##*/}" --append="${*:-$append}")

[[ $initrd ]] && kexec_cmd+=(--initrd="/boot/${initrd##*/}")

printf 'executing: %s\n' "${kexec_cmd[*]}"
runcmd "${kexec_cmd[@]}"

