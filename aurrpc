#!/bin/bash

#
# stupid proof of concept bash based AUR agent
#

shopt -s extglob

declare -l header             # response headers aren't always Mixed-Case
declare content_encoding=cat  # default NOOP decompressor

uastring="bashium 0.2 (bash ${BASH_VERSINFO[0]}-${BASH_VERSINFO[1]})"

hostname='aur.archlinux.org'
port='80'
bufsiz=4096
fmt_pkgpath='/packages/%s/%s.tar.gz'
fmt_rpcpath='/rpc.php?type=%s&arg=%s'

usage() {
  printf -- 'Usage: %s operation targets...\n\n' "${0##*/}"
  printf -- 'Operations:\n'
  printf -- '\t-d    download\n'
  printf -- '\t-i    package info\n'
  printf -- '\t-m    search by maintainer\n'
  printf -- '\t-s    search by package\n\n'
  exit 1
}

die() {
  error "$@"
  exit 1
}

error() {
  local mesg=$1; shift
  printf "\033[1;31m::\033[0m $mesg\n" "$@"
}

warn() {
  local mesg=$1; shift
  printf "\033[1;33m::\033[0m $mesg\n" "$@"
}

info() {
  local mesg=$1; shift
  printf "\033[1;34m::\033[0m \033[1m$mesg\033[0m\n" "$@"
}


# content handlers
json() {
  type -P json_reformat >/dev/null && json_reformat || cat
}

x-tgz() {
  tar xz
  if (( $? )); then 
    error 'error downloading %s' "$target"
  else
    info '%s downloaded to %s' "$target" "$PWD"
  fi
}


# decompress handlers
gzip() {
  command gzip -cd
}

deflate() {
  uncompress -c
}


# connect handler
connect() {
  { exec 4<>/dev/tcp/$hostname/$port; } 2>/dev/null
  (( $? )) && { die 'error: failed to connect to %s:%s\n' "$hostname" "$port"; }
}


# request handler
send_http_request() {
  printf 'GET %s HTTP/1.1\r
User-Agent: %s\r
Host: %s\r
Accept-Encoding: gzip,deflate\r
Accept: */*\r
Connection: Keep-Alive\r
\r
' "$1" "$uastring" "$hostname" >&4
}


# response handlers
read_response_code() {
  read -r -u 4 _ resp _
  if [[ $resp ]]; then
    if (( resp == 404 )); then
      die "package \`%s' not found" "$target"
    elif (( resp >= 300 )); then
      die "server responded with HTTP %d" "$resp"
    fi
    # assume HTTP 200 (eww)
  fi
}

read_response_headers() {
  # read response until the end of the headers
  while IFS=': ' read -r -u 4 header value; do
    # end of headers
    [[ $header = $'\r' ]] && break

    read -r -d $'\r' "${header//-/_}" <<< "$value"
  done

  content_type=${content_type##*/} # trim 'application/'

  if [[ $(type -t $content_type) = !(function|file) ]]; then
    die 'unknown/unhandled content type: %s\n' "$content_type"
    exit 1
  fi

  if [[ $(type -t $content_encoding) = !(function|file) ]]; then
    die 'unknown/unhandled encoding type: %s\n' "$content_encoding"
    exit 1
  fi
}

read_buffered() {
  fd=$1 len=$2

  while (( len > 0 )); do
    (( len > bufsiz )) && readlen=$bufsiz || readlen=$len
    actual=$(<&$fd dd bs=1 count=$readlen 2>/dev/null | tee >(wc -c) >&2)
    (( len -= actual ))
  done 2>&1
}

read_response_body() {
  if (( content_length )); then
    read_buffered 4 $content_length | $content_encoding | $content_type
  elif [[ "$transfer_encoding" = chunked ]]; then
    while true; do
      read -r -d $'\r\n' -u 4 len           # read length, consume \r
      read -r -n 1 -u 4 _                   # consume \n

      len=$(( 0x$len ))                     # convert hex2dec
      if (( len == 0 )); then               # exit condition
        read -r -n 4 -u 4 _                 # consume final \r\n\r\n
        break
      fi

      read_buffered 4 $len                  # read response body

      read -r -n 2 -u 4 _                   # consume \r\n
    done | $content_encoding | $content_type
  else
    $content_encoding <&4 | $content_type
  fi
}

# shutdown socket on exit
trap 'exec 4<&-' 0 QUIT TERM INT

# main()
while getopts ':dhims' opt; do
  case $opt in
    d) uri=$fmt_pkgpath; rtype=dl ;;
    h) usage ;;
    i) uri=$fmt_rpcpath; rtype=rpc; qtype=info ;;
    m) uri=$fmt_rpcpath; rtype=rpc; qtype=msearch ;;
    s) uri=$fmt_rpcpath; rtype=rpc; qtype=search ;;
    ?) die '%s: invalid option -- '\''%s'\' "${0##*/}" "$OPTARG"
       exit 1 ;;
    *) usage ;;
  esac
done
shift $(( OPTIND - 1 ))

(( $# )) || usage

connect
for target; do
  send_http_request "$(printf "$uri" "${qtype:-$target}" "$target")"
  read_response_code
  read_response_headers
  read_response_body
done

