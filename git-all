#!/bin/bash

[[ $1 = "-h" ]] && {
  echo "Usage: ${0##*/} [-f] [command]";
  echo;
  echo "     -f      suppress prompting before a custom command is run";
  echo "     -v      be verbose. show output for each repo";
  echo;
  echo "repos with uncommitted changes will be reported if no command is provided";
  exit 1;
}

verbose=0
repohome=$HOME
count=0
declare -a fail
declare -a pass

msg() {
  local mesg=$1; shift
  printf "\033[1;32m==>\033[1;0m\033[1;1m ${mesg}\033[1;0m\n" "$@" >&2
}

msg2() {
  local mesg=$1; shift
  printf "\033[1;34m  ->\033[1;0m\033[1;1m ${mesg}\033[1;0m\n" "$@" >&2
}

repopass() {
  printf "\033[0;37m %-60s \033[1;0m\033[0;34m[\033[1;37mPASS\033[0;34m]\033[0m\n" "$1"
}

repofail() {
  printf "\033[0;37m %-60s \033[1;0m\033[0;34m[\033[1;31mFAIL\033[0;34m]\033[0m\n" "$1"
}

# caught a custom arg, verify before proceeding
if [[ $# -gt 0 ]]; then
  if [[ $1 = "-f" ]]; then
    shift
  elif [[ $1 = "-v" ]]; then
    verbose=1
    shift
  else
    msg "Command to be executed: $*"
    read -N1 -p "  Are you sure you want to do this? [y/N] " reply
    echo;echo;

    [[ ! "$reply" =~ [Yy] ]] && exit 1
  fi
fi

# validate the command we were given
type -P $1 &> /dev/null || {
  echo "Invalid command: '$1'";
  exit 1;
}

# do it
while read repo; do
  repo=${repo%.git}
  cd "$repo"
  if [[ $# -eq 0 ]]; then
    [[ -n $(git status -s | grep -v "^??") ]] && echo "$repo"
  else
    (( count++ ))
    { (( verbose )) && {
        msg2 "In '$repo'";
        "$@";
      } || "$@" >/dev/null;
    } && pass=(${pass[@]} "$repo") || errors=(${errors[@]} "$repo")
  fi
done < <(find "$repohome" -type d -name '.git')

# print job summary
if [[ $# -ne 0 ]]; then
  msg "Action Summary for $count repos:"

  if [[ ${#fail[@]} -eq 0 ]]; then
    msg2 "No errors were reported"
  else
    echo "Errors occurred in the following repos:"
    for repo in "${fail[@]}"; do
      repofail "$repo"
    done
  fi
  echo

  for repo in "${pass[@]}"; do
    repopass "$repo"
  done
  echo
fi

